#!/usr/bin/env python3
import sys # for exit
import os # for checking file existance
from math import ceil # for arithmetic
import argparse # for argument processing
import logging # for simple debug logger

# add values to dictionary for different chips
# TODO: come up with a more robust way of doing this, values will collide eventually.
# TODO: split more stuff into functions, make this script more readable
# TODO: send all data to EEPROM in binary, not ascii!

eeprom_id_values = {0x7: "GLS29EE010", 0x8: "GLS29VE010"}

if __name__ == "__main__":
	logger = logging.getLogger('eeprom_parse_logger')
	
	parser = argparse.ArgumentParser(description='Python script to interface with EEPROMs.')
	parser.add_argument('--version', action='version', version='EEPROM flasher tool v0.2')
	parser.add_argument('-a', '--action', type=str, default='nop', help='action to perform: id, read, write, erase, and nop.')
	parser.add_argument('-d', '--device', type=str, help='device to communicate with, usually something like \'/dev/ttyUSB0\'.')
	parser.add_argument('-v', '--verbose', type=str, default='verbose', help='enable more verbose output, options are \'verbose\' and \'debug\'.')
	parser.add_argument('-b', '--binary', type=str, default='', help='binary to manipulate.')
	parser.add_argument('-s', '--size', type=int, default=0x1FFFF, help='EEPROM size, defaults to 128K.')
	args = parser.parse_args()

	EEPROM_SIZE = args.size
	
	if args.verbose == 'verbose':
		logger.setLevel(logging.INFO)
	elif args.verbose == 'debug':
		logger.setLevel(logging.DEBUG)
		logging.debug("Debug information enabled.")
	try:
		import serial
	except ModuleNotFoundError:
		logger.error("pyserial module not found!")
		logger.info("try \'pip3 install pyserial\'")
		sys.exit(2)
	else:
		logger.info("pyserial module found.")
	
	try:
		if args.device == None:
			raise IOError
		with open(args.device) as file:
			pass
	except IOError as bad_file:
		logger.error('Device file cannot be opened.')
		sys.exit(1)
	
	logger.info("Opening serial port with 8N1 2M baud settings...")
	serport = serial.Serial(args.device, 2000000, timeout=5)
	serport.readline()

	if args.action == 'erase':
		print("Erasing EEPROM chips...", end='')
		serport.write("ER;".encode('ascii', 'encode'))
		temp = serport.readline()
		while temp != b'done.\r\n':
			temp = serport.readline()
		print("done.")
	elif args.action == 'id':
		print("Version info:")
		serport.write("VE;".encode('ascii', 'encode'))
		print(serport.readline().decode('ascii').strip('\n')) # reader version
		print(serport.readline().decode('ascii').strip('\n')) # manufacturer ID
		num = serport.readline().decode('ascii').strip('\n') # device ID
		print("Device: ", end='')
		print(eeprom_id_values[int(num[11:14], 16)])
		
	elif args.action == 'write':
		try:
			with open(args.binary, "rb") as binfile:
				bindata = binfile.read(EEPROM_SIZE)
		except IOError:
			logger.error("binary cannot be opened!")
			sys.exit(4)
		else:
			logger.info("binary located.")
		
		# TODO: make sure byte and word order is same as 68k memory layout!
		
		# write all the pages up to the last one, since the last one may not be on a page boundary.
		
		endpage = len(bindata) + (128 - len(bindata) % 128)
		
		print("Writing " + str(endpage) + " bytes to EEPROM...")
		
		for page in range(0, endpage, 128):
			page_str = "WP:" + str(page)
			for byte in range(0, 256, 2):
				if (page + byte) >= len(bindata):
					page_str += ":0"
				else:
					page_str += ":" + str(bindata[page + byte])
			page_str += ";"
			logger.debug(page_str)
			
			serport.write(page_str.encode("ascii", "encode"))
			temp = serport.readline()
			while temp != b'done.\r\n':
				temp = serport.readline()
			print("writing page " + str((page // 128) + 1) + "/" + str(endpage // 128) + "...")
		print("done.")
	
	# takes ~6 seconds with 2M baud, 128K EEPROM
	elif args.action == 'read':
		print("Reading EEPROM contents into file ", end='')
		print(args.binary, end='')
		print("...")
		
		try:
			with open(args.binary, "wb") as readfile:
				logger.info("binary located.")

				for page in range(0, EEPROM_SIZE, 128):
					page_str = "RP:" + str(page) + ";"
					serport.write(page_str.encode("ascii", "encode"))
					
					temp = serport.readline()[:-1] # strip out \n
					logger.debug(temp)
					readfile.write(temp)

		except IOError:
			logger.error("binary cannot be opened!")
			sys.exit(5)

	elif args.action == 'nop':
		logger.info('doing nothing.')
	
	else:
		logger.error("unknown action!")
		sys.exit(1)
	
