bad ideas:
	letting the MMU handle illegal accesses to low 128K of memory - MMU has to sit between processor and memory
	remove pullup on AS - there to prevent spurious memory acceses once bus master is done and CPU has not relinquished control of the bus yet
	having the processor wait for the UART host to transmit a binary - will hang if the board should be booting from a stored EEPROM program
	supervisor access only to EEPROM - prevents user from using hardware libs, initial supervisor -> user jump is awkward at best
	having MFP drive IRQ lines directly - if a priority level 2 interrupt and level 1 interrupt fire at the same time, the processor will register a level 3 interrupt.

maybe ideas:
	having an MMU board at all - 68451 chip is kinda hard to find on eBay and pretty expensive too, couldn't find a PLCC package for it
	
ideas for add-on boards:
	
	NOTE: all add-on boards have to have space for a board to be stacked on top of them, PC104 style
	
	Paper tape reader for fun
		Use a CPLD for interfacing with the board
		Might teach me something about proper motor control
		Uses either a cardboard or LEGO structure to read in holes punched into the tape
		Once that is done, use a solenoid motor to possibly punch holes in a new tape and output it
	
	Interface options:
		SPI using the MFP I/O pins - slow, but easier to implement
		External device grabs host memory using DMA (FPGA or CPLD with microcontroller)
			significantly faster
			harder to design
			requires host board modification since the DMA functionality is broken currently
		Dual-ported RAM
			a good idea for video stuff, especially 3D applications
		FIFO chips
			good for ingesting lots of fast data
			could be part of a high-speed 8-bit parallel bus - clocked way higher than the processor itself?
			if using the AM7202A chip lying around, I could use the 9th bit to do hardware parity checking

misc ideas:
	put some artwork or something cool on the bottom side if it doesn't add too much to the cost of the board
	make it so the bootloader program contains a lot of test code, and the board could read an unimplemented area of memory to determine what tests to run.

toolchain todo:
	decide how much stuff I want to write in C vs assembly
	write a linker script and assembly file containing _start, use it with GCC (can't use the standard _start since I have special requirements as to the memory layout)
	write code in C, test on an x64 machine
