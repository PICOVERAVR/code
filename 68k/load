#!/usr/bin/env python3
import argparse
import sys

if __name__ == "__main__":
	""" uploads code to the 68k board, which may or may not go into the EEPROMs.  Self-updating is not currently supported.
	
	This depends heavily on the construction of the bootloader, so this is a work in progress until the bootloader for the device itself is done.
	
	"""
	parser = argparse.ArgumentParser(description='Python script to upload code to a 68k board with a UART attached.')
	parser.add_argument('--version', action='version', version='Code upload tool v0.1')
	parser.add_argument('-d', '--device', type=str, help='UART device path')
	parser.add_argument('-b', '--binary', type=str, help='binary path')
	parser.add_argument('-s', '--speed', type=int, default=115200, help='baud rate to communicate at, defaulting to 115200')
	parser.add_argument('-l', '--load', type=str, help='specify whether to put binary in RAM or EEPROM')
	parser.add_argument('-i', '--size', type=int, default=0x1FFFF, help='size of flash memory, script will stop if binary is bigger than this')
	# TODO: add option for booting into supervisor mode instead of user mode

	args = parser.parse_args()
	
	try:
		import serial
	except ModuleNotFoundError:
		print("pyserial module not found!")
		sys.exit(1)
	
	try: # open device file for Arduino
		if args.device == None:
			raise IOError
		#with open(args.device) as file: # TODO: fix this
		#	pass
	except IOError as bad_file:
		print("cannot open device file!")
		sys.exit(2)
	
	print("Opening serial port with 8N1 " + str(args.speed) + " baud settings...")
	serport = serial.Serial(args.device, args.speed, timeout=5)

	try: # open binary to write
		with open(args.binary, "rb") as binfile:
			bindata = binfile.read()
	except IOError:
		print("binary cannot be opened!")
		sys.exit(3)

	config_byte = 0
	if args.load != "EEPROM" and args.load != "RAM":
		print("invalid target!")
		sys.exit(4)
	else:
		if args.load == "EEPROM":
			config_byte |= 0x1
	
	bin_length = len(bindata)
	if (bin_length > args.size):
		print("binary size is greater than memory will allow!")
		sys.exit(5)

	print("writing " + str(bin_length) + " bytes to " + args.load, end='')
	
	serport.write(config_byte)

	# write the length of the incoming binary, one byte at a time
	# doing this manually since bootloader expects 4 bytes regardless of value
	
	# TODO: write this as MSB first.
	for i in range(0, 4):
		if bin_length == 0:
			serport.write(0)
		else:
			pass
	
	serport.write(bindata)
	
	print("done.")

