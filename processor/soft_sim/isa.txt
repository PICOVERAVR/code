ISA
=======

16 bit RISC processor

//give a reason this is different than RISC-V.

32 16-bit registers (R0 - R31)
	R31: PC - hardwired
	R30: SP
	R29: BP
	R0:  0x0 - hardwired
	

Three operand format for everything
register-register architecture

no status register, just compare and branch

control
	HALT			stop the processor

math
	ADD s0, s1, d	s0 + s1 (signed 16b)   -> d
	ADDU s0, s1, d	s0 + s1 (unsigned 16b) -> d
	ADDB s0, s1, d	s0 + s1 (signed 8b)    -> d
	ADDUB s0, s1, d s0 + s1 (unsigned 8b)  -> d
	
	SUB s0, s1, d	s0 - s1 (signed 16b)   -> d
	SUBU s0, s1, d	s0 - s1 (unsigned 16b) -> d
	SUBB s0, s1, d	s0 - s1 (signed 8b)    -> d
	SUBUB s0, s1, d s0 - s1 (unsigned 8b)  -> d

	MUL s0, s1, h, L	s0 * s1 (signed 32b)    -> {h, L}
	MULU s0, s1, h, L	s0 * s1 (unsigned 32b)  -> {h, L}
	MULB s0, s1, d		s0 * s1 (signed 16b)    -> d
	MULUB s0, s1, d 	s0 * s1 (unsigned 16b)  -> d
	
	DIV s0, s1, p, r	s0 / s1 (signed 16b)   -> {d0, d1}
	DIVU s0, s1, p, r	s0 / s1 (unsigned 16b) -> {d0, d1}
	DIVB s0, s1, p, r	s0 / s1 (signed 16b)   -> {d0, d1}
	DIVUB s0, s1, p, r	s0 / s1 (unsigned 16b) -> {d0, d1} //do we need all this?
	
	SEX s			sign of 8b num 	       -> 16b sign(d) //always two's compliment
	
	// inc and dec functionality provided by ADD r, 1, r
	
	AND s0, s1, d	s0 & s1 (signed 16b)   -> d
	ANDU s0, s1, d	s0 & s1 (unsigned 16b) -> d
	ANDB s0, s1, d  s0 & s1 (signed 8b)    -> d
	ANDUB s0, s1, d s0 & s1 (unsigned 8b)  -> d
	

moving
	MOV s, d	s (16b)		-> d
	MOVB s, d	s (8b)		-> d
	
	LD addr, r	mem[addr]	-> r //no LDB or STB, makes things easier for memory accesses?
	LD i, r		mem[i]		-> r
	LD imm, r	imm		-> r
	
	ST r, addr	r		-> addr
	ST r, i		r		-> mem[i]
	ST r, imm	r		-> mem[imm]
	
branching
	BN lit		lit		-> pc
	BS r, add	s0 + s1		-> pc //branch to r = BS r, R0

	BR r		pc + r		-> pc //r treated as 16bu
	
	BE s, d, r	(s == d)?	-> r //no literal jumping like this
	BNE s, d, r	(s != d)?	-> r
	
	BGT s, d, r	(s > d)?	-> r
	BGE s, d, r	(s >= d)?	-> r

	BLT s, d, r	(s < d)?	-> r
	BLE s, d, r	(s <= d)?	-> r
	
	BZ s, r		(s == 0)?	-> r
	BNZ s, r	(s != 0)?	-> r

stack
	// nothing new here

instruction encoding

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx| pm  |    op    |  -> HALT (A)
|xxxxxxxxxxxxxxxx|                        imm                      | pm  |    op    |  -> BN imm (B)
|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|      r      | pm  |    op    |  -> INC r (C)
|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|      s       |      d      | pm  |    op    |  -> MOV s, d (D)
|x|                   imm                            |      r      | pm  |    op    |  -> LD imm, r (E)
|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|      s       |     addr    | pm  |    op    |  -> ST r, addr(D)
|xxxxxxxxxxxxxxxxxxxxxx|      s0      |      s1      |      d      | pm  |    op    |  -> ADD s0, s1, d (F)
|xxxxxxx|      s0      |      s1      |      h       |      l      | pm  |    op    |  -> MUL s0, s1, h, L (G)

	
opcode encoding
	all 0 opcode is illegal (STOP pseudo-i in this sim)
	 9 8 7 6 5 4 3 2 1 0
	  |x x h|  NOP(x)  | h = 1 for halt
	  |i b s|  ADD(x)  | b = 1 for word, s = 1 for signed
	  |x b x|  MOV(x)  | b = 1 for word
	  |x x m|  LD(x)   | m = 1 for mem, 0 for imm
	  |x x x|  ST(x)   | 
	  |x b i|  INC(x)  | i = 1 for inc, b = 1 for word
	  |x x x|  BN(x)   |
	  |x x r|  BR(x)   | r = 1 for +r //has to be seperate from BN due to differing encoding
	  |x x n|  BNZ(x)  | n = not equal



